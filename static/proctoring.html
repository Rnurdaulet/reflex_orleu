<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Proctoring Debug</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection"></script>
    <style>
        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 320px;
            height: 240px;
            transform: scaleX(-1);
        }

#log, #checklist {
  position: absolute;
  left: 0;
  bottom: 60px; /* –æ—Ç—Å—Ç—É–ø –æ—Ç –Ω–∏–∑–∞ –æ–∫–Ω–∞ */
  background: rgba(0,0,0,0.7);
  color: white;
  padding: 8px;
  font-family: monospace;
  font-size: 12px;
  max-width: 320px;
  z-index: 999;
}
#log{
    top:0;
     bottom: 220px;
}

#checklist {
  bottom: 0;
}

    </style>
</head>
<body>
<video id="video" autoplay muted playsinline width="320" height="240"></video>
<canvas id="output" width="320" height="240"></canvas>
<div id="log">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
<div id="checklist">‚è≥ –ß–µ–∫-–ª–∏—Å—Ç –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è...</div>

<script>
    function updateChecklist({faceScale, ratio, headTiltDown, multiFace}) {
        const checks = [];

        if (faceScale < 30) checks.push("–°–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ ‚ùå");
        else if (faceScale > 80) checks.push("–°–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ ‚ùå");
        else checks.push(" –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ: ‚úÖ");

        if (ratio < 0.607) checks.push("–ü–æ–≤–æ—Ä–æ—Ç ‚ùå");
        else checks.push("–ü–æ–≤–æ—Ä–æ—Ç: ‚úÖ");

        if (headTiltDown > -1) checks.push("–ù–∞–∫–ª–æ–Ω ‚ùå");
        else checks.push("–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ: ‚úÖ");

        if (multiFace) checks.push("üë• –ù–µ—Å–∫–æ–ª—å–∫–æ –ª–∏—Ü –≤ –∫–∞–¥—Ä–µ ‚ùó");

document.getElementById("checklist").innerHTML = checks.join("<br>");

    }


    console.clear();
    const log = (msg) => {
        document.getElementById('log').textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        console.log(msg);
    };

    async function setupCamera() {
        const video = document.getElementById('video');
        try {
            const stream = await navigator.mediaDevices.getUserMedia({video: {width: 320, height: 240}});
            video.srcObject = stream;
            return new Promise(resolve => {
                video.onloadedmetadata = () => {
                    log("–ö–∞–º–µ—Ä–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞");
                    resolve(video);
                };
            });
        } catch (e) {
            log("–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ");
            console.error("Camera error:", e);
            throw e;
        }
    }

    function isBlackFrame(video, ctx) {
        const frame = ctx.getImageData(0, 0, video.videoWidth, video.videoHeight);
        const data = frame.data;
        let sum = 0;
        for (let i = 0; i < data.length; i += 4) {
            const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
            sum += brightness;
        }
        const avg = sum / (data.length / 4);
        return avg < 15;
    }

    async function run() {
        try {
            const video = await setupCamera();
            await video.play();

            const canvas = document.getElementById('output');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');

            log("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è TensorFlow...");
            await tf.setBackend('webgl');
            await tf.ready();
            log("TensorFlow –≥–æ—Ç–æ–≤");

            log("–ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏...");
            const detector = await faceLandmarksDetection.createDetector(
                faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh,
                {
                    runtime: 'tfjs',
                    maxFaces: 3,
                    refineLandmarks: true
                }
            );
            log("–ú–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞");

            const detect = async () => {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                if (isBlackFrame(video, ctx)) {
                    log("–ß—ë—Ä–Ω—ã–π —ç–∫—Ä–∞–Ω");
                    return requestAnimationFrame(detect);
                }

                const faces = await detector.estimateFaces(video);
                let faceScale = 0;
                let headTiltDown = 0;
                let ratio = 1;

                if (!faces.length) {
                    log("–õ–∏—Ü–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ");
                    updateChecklist({faceScale, ratio, headTiltDown, multiFace: false});
                    return requestAnimationFrame(detect);
                }

                if (faces.length > 1) {
                    log(`–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ª–∏—Ü: ${faces.length}`);
                    updateChecklist({faceScale, ratio, headTiltDown, multiFace: true});
                    return requestAnimationFrame(detect);
                }


                const face = faces[0];
                const landmarks = face.keypoints;
                const leftEye = landmarks.find(p => p.name === 'leftEye') || landmarks[133];
                const rightEye = landmarks.find(p => p.name === 'rightEye') || landmarks[362];
                const leftEar = landmarks[234];
                const rightEar = landmarks[454];

                const eyeDist = Math.abs(rightEye.x - leftEye.x);
                faceScale = eyeDist;

                const avgEyeY = (leftEye.y + rightEye.y) / 2;
                const avgEarY = (leftEar.y + rightEar.y) / 2;
                headTiltDown = avgEyeY - avgEarY;

                const faceWidth = Math.abs(rightEar.x - leftEar.x);
                ratio = eyeDist / faceWidth;
                updateChecklist({faceScale, ratio, headTiltDown, multiFace: false});

                log("‚úÖ –õ–∏—Ü–æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ");
                requestAnimationFrame(detect);
            };

            detect();
        } catch (e) {
            log("–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞");
            console.error("–û—à–∏–±–∫–∞ –≤ run():", e);
        }
    }

    run();
    window.parent.postMessage({
        type: "violation",
        data: {reason: "no_face", duration: 3}
    }, "*");

</script>
</body>
</html>
